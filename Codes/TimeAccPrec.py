#
# A python script to parse and plot data from the TimeCompare.py code running on the ESP8266 microcontroller
#
# Danny Grunbaum, SoO, 20180116
#
from scipy import stats
import numpy as np
import matplotlib.pyplot as plt
import os, glob


def list_TC_datafiles(data_directory='.', template="*.txt",exclude=None):
    """ A method to list time-keeping data files generated by TimeCompare.py"""
    # Get a list of files which match the template, from the specified data directory
    file_list=[]              # A list of filenames

    for file in glob.glob(data_directory+os.path.sep+template):
        if (exclude is None) or (exclude not in file):
            file_list.append(file)

    print('Found ',len(file_list),' files to parse...')    
    return file_list

def parse_TC_data(filename,sub_samples=None):
    """ A method to parse time-keeping data from a file generated by TimeCompare.py"""
    # Initialize lists to hold data from file being parsed
    seconds_onboard=[]
    seconds_external=[]
    seconds_NTP=[]

    # Lists to contain elapsed time for each method
    diff_onbrd_ext=[]
    diff_NTP_ext=[]
    diff_NTP_onbrd=[]

    # Lists to contain sub plot data, if requested...
    if sub_samples is not None:  #  Record the requested samples (if any)          
        ss_onbrd_ext=[]
        ss_NTP_ext=[]
        ss_NTP_onbrd=[]
        
    # Read each line in the file, splitting up the different numbers and appending them onto the
    # appropriate list
    with open(filename,'r') as file:
        counter=0
        for line in file:
            data=line.split(' ') # We use a space as a delimiter
            # The first number is the sample number. Subsequent numbers are day, hour, minute, second
            # for each of onboard RTC, external RTC and NTP server.
            sample_num=int(data[0]) 
            
            # Data from the onboard RTC
            day_onboard=int(data[1])
            hour_onboard=int(data[2])
            min_onboard=int(data[3])
            sec_onboard=int(data[4])

            # Data from the external (DS3231) RTC
            day_external=int(data[5])
            hour_external=int(data[6])
            min_external=int(data[7])
            sec_external=int(data[8])
            
            # Data from the NTP server
            day_NTP=int(data[9])
            hour_NTP=int(data[10])
            min_NTP=int(data[11])
            sec_NTP=int(data[12])

            # Convert time data into seconds, and record them
            seconds_onboard.append(sec_onboard+60*(min_onboard+60*(hour_onboard+24*day_onboard)))
            seconds_external.append(sec_external+60*(min_external+60*(hour_external+24*day_external)))
            seconds_NTP.append(sec_NTP+60*(min_NTP+60*(hour_NTP+24*day_NTP)))

            if len(seconds_external)==1:
                # Record starting seconds. We use the external RTC as the standard. 
                starting_seconds_external=seconds_external[0]
                
            # Calculate the elapsed time for each method, and the differences among the methods    
            diff_onbrd_ext.append(seconds_onboard[counter]-seconds_external[counter])
            diff_NTP_ext.append(seconds_NTP[counter]-seconds_external[counter])
            diff_NTP_onbrd.append(seconds_NTP[counter]-seconds_onboard[counter])
            seconds_onboard[counter]-=starting_seconds_external
            seconds_external[counter]-=starting_seconds_external
            seconds_NTP[counter]-=starting_seconds_external

            counter+=1            

    print('parsed ',len(seconds_external),' data lines...')

            
    if sub_samples is not None:  #  Record the requested samples (if any)          
        try:                                    #  in the violin plot data
            # Create a list of times for requested samples,usaing the lastest external seconds count
            ss_times=[seconds_external[i] for i in sub_samples]
            ss_onbrd_ext=[diff_onbrd_ext[i] for i in sub_samples]
            if min(seconds_NTP)>=0:  # Include NTP comparisons only if they all worked (no -1 values)
                ss_NTP_ext=[diff_NTP_ext[i] for i in sub_samples]
                ss_NTP_onbrd=[diff_NTP_onbrd[i] for i in sub_samples]
        except:
            print("Failed to find subsample data point in ",filename)

        return (diff_onbrd_ext, diff_NTP_ext, diff_NTP_onbrd,
                seconds_onboard, seconds_external, seconds_NTP,
                ss_times, ss_onbrd_ext, ss_NTP_ext, ss_NTP_onbrd)
    else:      # No sub plot data
        return (diff_onbrd_ext, diff_NTP_ext, diff_NTP_onbrd,
                seconds_onboard, seconds_external, seconds_NTP)



def lineplot_TC_data(fig,axes,data_directory='.', template="*.txt",plt_style='.',exclude=None):
    # Plot TimeCompare data from files matching the template with lines,
    # superimposing symbols for files that also contain the uniqueID.
    file_list = list_TC_datafiles(data_directory=data_directory, template=template,exclude=exclude)

    # Loop through all files, parsing the data from each
    for ifile in range(len(file_list)):
        try:
            filename = file_list[ifile]
            print('Parsing file ',filename)
            (diff_onbrd_ext, diff_NTP_ext, diff_NTP_onbrd,
                 seconds_onboard, seconds_external, seconds_NTP) =  parse_TC_data(filename)

            axes[0].plot(seconds_external,diff_onbrd_ext,plt_style)
            if min(seconds_NTP)>=0:  # Include NTP comparisons only if they all worked (no -1 values)
                axes[1].plot(seconds_external,diff_NTP_ext,plt_style)
                axes[2].plot(seconds_external,diff_NTP_onbrd,plt_style)

            # Label the elapsed time error plots    
            axes[0].set_title('Time Differences ($s$)')
            axes[2].set_xlabel('Elapsed time ($s$)')

            axes[0].set_ylabel('Onboard RTC - DS3231 RTC')
            axes[1].set_ylabel('Difference: NTP - DS3231 RTC')
            axes[2].set_ylabel('Difference: NTP - Onboard RTC')
            
        except:
            print('Failed parsing file ',filename)

def subsample_TC_data(data_directory='.', template="*.txt",sub_samples=None,exclude=None):
    """ A method to subsample time-keeping data from files generated by TimeCompare.py,
         keeping observations with indices appearing in the list subsamples. """
    # Get a list of files which match the template, from the specified data directory
    file_list = list_TC_datafiles(data_directory=data_directory, template=template,exclude=exclude)

    subsample_onbrd_ext=[]
    subsample_NTP_ext=[]
    subsample_NTP_onbrd=[]
    subsample_times=[]
    
    # Loop through all files, parsing the data from each
    for ifile in range(len(file_list)):
        try:
            filename = file_list[ifile]
            print('Parsing file ',filename)
            (diff_onbrd_ext, diff_NTP_ext, diff_NTP_onbrd,
                 seconds_onboard, seconds_external, seconds_NTP,
                 ss_times, ss_onbrd_ext, ss_NTP_ext, ss_NTP_onbrd) =  parse_TC_data(filename,sub_samples=sub_samples)
        except:
            print('Failed parsing file ',filename)

        # Record the requested samples in the sub plot data
        try:
            #print(ss_onbrd_ext)
            subsample_onbrd_ext.append(ss_onbrd_ext)
            if min(seconds_NTP)>=0:  # Include NTP comparisons only if they all worked (no -1 values)
                subsample_NTP_ext.append(ss_NTP_ext)
                subsample_NTP_onbrd.append(ss_NTP_onbrd)
        except:
            print("Failed to find subsample data in ",file)

        # Create a list of times for requested samples,usaing the lastest external seconds count
        # NOTE: This assumes a consistent dataset but does not check for it (it should).
        subsample_times=ss_times
            
    return (subsample_times,subsample_onbrd_ext,subsample_NTP_ext,subsample_NTP_onbrd)


def violinplot_TC_data(fig,axes,ss_times,ss_onbrd_ext,ss_NTP_ext,ss_NTP_onbrd,v_widths=200.,bw=0.5):
    """ A method to create violin plots to visualize time error distributions
    """
    # Convert data to numpy arrays and plot:
    axes[0].violinplot(np.array(ss_onbrd_ext),ss_times, vert=True, widths=v_widths,bw_method=bw,
                          showmeans=True, showextrema=True, showmedians=False)
    axes[1].violinplot(np.array(ss_NTP_ext),ss_times, vert=True, widths=v_widths,bw_method=bw,
                          showmeans=True, showextrema=True, showmedians=False)
    axes[2].violinplot(np.array(ss_NTP_onbrd),ss_times, vert=True, widths=v_widths,bw_method=bw,
                          showmeans=True, showextrema=True, showmedians=False)
    # Label the violin plots
    axes[0].set_title('Violin plots')
    axes[2].set_xlabel('Elapsed time ($s$)')

    axes[0].set_ylabel('Onboard RTC - DS3231 RTC')
    axes[1].set_ylabel('NTP - DS3231 RTC')
    axes[2].set_ylabel('NTP - Onboard RTC')

    # Turn on gridding
    axes[0].grid(True)
    axes[1].grid(True)
    axes[2].grid(True)

def prcntplot_TC_data(fig,axes,ss_times,ss_onbrd_ext,ss_NTP_ext,ss_NTP_onbrd,pcnts=[5.,25.,50.,75.,95.]):
    """ A method to create percentile plots to visualize time error distributions
    """
    # Convert data to numpy arrays and plot:
    axes[0].plot(ss_times,np.percentile(np.array(ss_onbrd_ext),pcnts,axis=0,keepdims=False).transpose())
    axes[1].plot(ss_times,np.percentile(np.array(ss_NTP_ext),pcnts,axis=0,keepdims=False).transpose())
    axes[2].plot(ss_times,np.percentile(np.array(ss_NTP_onbrd),pcnts,axis=0,keepdims=False).transpose())
    
    # Label the plots
    axes[0].set_title('Percentile plots')
    axes[2].set_xlabel('Elapsed time ($s$)')

    axes[0].set_ylabel('Onboard RTC - DS3231 RTC')
    axes[1].set_ylabel('NTP - DS3231 RTC')
    axes[2].set_ylabel('NTP - Onboard RTC')

    # Turn on gridding
    #axes[0].grid(True)
    #axes[1].grid(True)
    #axes[2].grid(True)

def probplot_TC_data(ax,ss_1,title,dst=stats.norm):
    """ A method to create probability plots to visualize time error distributions.
         Note that this implementation plots and analyzes only samples from the last subsampling interval.
    """
    # Convert data to numpy arrays and plot:
    ss=np.array(ss_1)[:,-1]
    
    (osm, osr),(slope, intercept, r) = stats.probplot(ss, dist=dst, plot=ax)
    print('slope = ',slope)
    print('intercept = ', intercept)
    print('sqr root coef. deter. = ',r,'\n\n')

    ax.set_title(' ')
    ax.set_ylabel(title+'\n Ordered Values')

    # Turn on gridding
    ax.grid(True)

    
def hypothesis_TC_data(ss_times,ss_1,ss_2,pcnts=[5.,25.,50.,75.,95.]):
    """ A method to perform hypothesis tests on time error distributions
    """
    print('\nDistribution 1 at times ',ss_times,':')
    print('Percentiles: ',pcnts)
    print(np.percentile(np.array(ss_1),pcnts,axis=0,keepdims=False).transpose())

    print('\nDistribution 2 at times ',ss_times,':')
    print('Percentiles: ',pcnts)
    print(np.percentile(np.array(ss_2),pcnts,axis=0,keepdims=False).transpose())

    for i in range(1,len(ss_times)):
        print('\n\nHypothesis tests: elapsed time = ',ss_times[i])
        ss=np.array(ss_1)[:,i]
        nss=np.array(ss_2)[:,i]
        print('dataset 1 = ',ss)
        print('dataset 2 = ',nss)

        # Perform hypothesis tests:
        rslt=stats.kruskal(ss, nss)
        print('kruskal: ',i, rslt)
        rslt2=stats.ranksums(ss, nss)
        print('ranksums: ',i, rslt2)
        rslt3=stats.ttest_ind(ss, nss, equal_var=False)
        print('t-test: ',i, rslt3)
    

